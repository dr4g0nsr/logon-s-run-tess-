
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	LET IT BIG!   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.init
 
		; init les 2 fois 96 octets de mask en letitbig.precalc.mask equ #EF00-#100-#200 (sous réserve)
			call letitbig.gen_mask
								
		; init l'y mod
			call letitbig.mod.tab_l0l1.init
			call letitbig.ymod.init

		; init avant la 1ère boucle sous int
			call letitbig.next_frame	
			
		; 7FC1: copie le code et initialise la table de rasters 
		 	jp letitbig.init.7FC1
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.main
		; rectif du code en 7FC2 ; <-- à terme peut-être à nettoyer ensuite
			ld hl,#51ED:ld (letitbig.code),hl:		ld (letitbig.eat1stlines.code),hl 
			ld hl,letitbig.src_code_fix:ld bc,letitbig.src_code_fix_end-letitbig.src_code_fix
			push hl:push bc
			ld de,letitbig.scanline_outi0:ldir
			pop bc:pop hl
			ld de,letitbig.scanline_outi1:ldir
			ld hl,letitbig.eat1stlines.src_code_fix:ld bc,letitbig.eat1stlines.src_code_fix_end-letitbig.eat1stlines.src_code_fix
			ld de,letitbig.eat1stlines.scanline_outi0:ldir
			
		; wait l'interruption à la VBL
			call sys.wait_int_vbl_is_over
		; wait la dernière interruption
			halt:halt:halt:halt
 if cond.colorz
 ld b,#7F:ld hl,#0156:out (c),h:out (c),l ; écran
 else
			ld b,#7F:ld hl,#0356:out (c),h:out (c),l ; écran
 endif
			halt
			
		; tempo
			call aks_regs
			ld a,aks_fix_val:ld (aks_fix_adr),a
			;
			ld hl,letitbig.int_7FC1:ld (#FDFD+1),hl
			;
			ld bc,#BC0C:out (c),c:ld bc,#BD00+high letitbig.crtc_offset:out (c),c ; crtc vram
			ld bc,#BC0D:out (c),c:ld bc,#BD00+low  letitbig.crtc_offset:out (c),c ; crtc offset sur 0000
			ld bc,#BC04:out (c),c:ld bc,#BD0A:out (c),c
			; dernier split 11*8 R4=#10 R7=#D
			; here? around VCC=7 VLC=6 HCC=40
			ld b,16*(8*3+1)-256+6-4-2:djnz $:djnz $
			; up to VCC=0 VLC=0
 if cond.colorz
 ld bc,#7F00:out (c),c:ld a,RGB222:out (c),a
 else
			ld bc,#7F00:out (c),c:ld a,RGB000:out (c),a	; set couleur pour raster
 endif
			ld b,2:djnz $
			if debug.syncbreak=1
				break
			endif										
			ld bc,#BC09:out (c),c:ld bc,#BD01:out (c),c
			ld bc,#BC04:out (c),c:ld bc,#BD00+6*8/2-1:out (c),c
			ld bc,#BC07:out (c),c:ld bc,#BD00+2*8/2:out (c),c
			ld bc,#BC06:out (c),c:ld bc,#BD00+1:out (c),c
		;reg0/reg2
			ld b,4:djnz $
			;break
			ld bc,#BC00:out (c),c:ld bc,#BD3F-8:out (c),c
			ld b,#30/4:djnz $
								  ld bc,#BD3F:out(c),c ; reg0 décalé
			ld bc,#BC02:out (c),c:ld bc,#BD32-8+8:out (c),c
 if cond.colorz
 ld bc,#BC01:out (c),c:ld bc,#BD30-4:out (c),c
 else
			ld bc,#BC01:out (c),c:ld bc,#BD30:out (c),c
 endif
		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; à partir d'ici, INT possible 

		; en tache de fond, la recopie du dernier tiers
			call letitbig.decrunch.toscreen.part_1

		; ajout de rotation pour allonger la durée d'animation
			ld a,(letitbig.num_frame+1):cp 3:jr nz,$-5
			ld a,(letitbig.num_frame+1):cp 2:jr nz,$-5
	
 	; y mod des colonnes		
 		; colonne du milieu, arrière-plan
			ld a,(letitbig.num_frame+1):cp 1:jr nz,$-5 ; empirique, avec 1 de marge ; testé #B
			ld hl,letitbig.tab_sp+8*22:ld b,13:call letitbig.ymod.loop
; 		; on attend la fin du script sous int. --> non, il est fini :)	
		 	call letitbig.switch_aks_to_top
			ld a,#21:ld (letitbig.call_buttons),a ; plus besoin de mettre à jour le raster pour le bouton
			
		; colonnes extremes, arrière-plan	
 			ld a,high (letitbig.mod.tab_conv+#100):ld (letitbig.ymod.adr_tab_conv+1),a
			ld hl,letitbig.tab_sp+8*14:ld b,28:call letitbig.ymod.loop
 		
		; colonne droite, devant ON
 			ld a,high (letitbig.mod.tab_conv+#200):ld (letitbig.ymod.adr_tab_conv+1),a
			ld hl,letitbig.tab_sp+8*(55-2):ld b,3:call letitbig.ymod.loop
			ld hl,letitbig.tab_sp+8*0     :ld b,14:call letitbig.ymod.loop
		
 		; colonne gauche, arrière-plan, OFF
 			ld a,high (letitbig.mod.tab_conv+#300):ld (letitbig.ymod.adr_tab_conv+1),a
			ld hl,letitbig.tab_sp+8*28:ld b,14:call letitbig.ymod.loop
 
		; colonne droite, devant OFF
 			ld a,high (letitbig.mod.tab_conv+#200):ld (letitbig.ymod.adr_tab_conv+1),a
			ld hl,letitbig.tab_sp+8*(55-2):ld b,3:call letitbig.ymod.loop
			ld hl,letitbig.tab_sp+8*0     :ld b,14:call letitbig.ymod.loop
 
 		; colonnes extremes, arrière-plan	== ici enlève droite, remet gauche et milieu :)
			ld a,(letitbig.num_frame+1):cp 17:jr nz,$-5
 			ld a,high (letitbig.mod.tab_conv+#100):ld (letitbig.ymod.adr_tab_conv+1),a
			ld hl,letitbig.tab_sp+8*14:ld b,28:call letitbig.ymod.loop

 		; colonnes du milieu == restera celle du mileu
			ld a,(letitbig.num_frame+1):cp 10:jr nz,$-5
 			ld a,high (letitbig.mod.tab_conv):ld (letitbig.ymod.adr_tab_conv+1),a
			ld hl,letitbig.tab_sp+8*22:ld b,13:call letitbig.ymod.loop
			
 		; on attend la frame n°0 pour la fixer
 			ld a,(letitbig.num_frame+1):or a:jr nz,$-4
 			halt ; pour avoir la frame avec le n°0
 			ld (letitbig.num_frame_inc+1),a

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;				

	; fin!

		ld a,#21:ld (letitbig.switch_no_next_frame),a
 		; à la sortie de letitbig 			R7= 2*8/2 +letitbig.constant_r4mod
		; 									soit      +10 = +2*8/2 +2 	i.e. faut DEUX lignes black de plus
		xor a:ld (letitbig.switch_no_bottom.reg4),a
		;break
		halt
		ld b,7+32:djnz $
		ld bc,#BC09:out (c),c:ld bc,#BD00+7:out (c),c
		; pour le retour en int vsync		VCC=0D VLC=01 pour R4=10 R7=0D forcément
		ld bc,#BC04:out (c),c:ld bc,#BD00+2+2	+#10-#0D	:out (c),c
		ld bc,#BC07:out (c),c:ld bc,#BD00+2+2				:out (c),c
		ld bc,#BC06:out (c),c:ld bc,#BD00+4					:out (c),c
		ld hl,@sys.int.im2_jp:ld (#FDFD+1),hl ; interruption normale
		ld hl,32*11:ld (scroller.inc_split+1),hl ; sans réplication des 11 1ères lignes
		ld a,1:ld (aks_fix_adr),a ; musique variable
		ld a,#8D:ld (sys.ink3val),a ; mode 1 à la VSYNC
		call sys.to_screen32x32
		halt
		ld bc,#BC06:out (c),c:ld bc,#BD00+11:out (c),c
		halt					
		ld bc,#BC07:out (c),c:ld bc,#BD00+#0D:out (c),c
		
	ret			
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;				
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;				
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.next_frame	
			ld a,0:inc a:and 1:ld ($-4),a ; cf le JR Z, juste après
letitbig.num_frame
			ld a,#38-1 ; faut avoir 0 la 1ère étape (?) ; testé -24
			jr z,2+$+2 ; faut que ça passe la 1ère fois
letitbig.num_frame_inc
			add a,1
			cp #38:jr nz,2+$+1:xor a
			;cp -1:jr nz,2+$+2:ld a,#38-1
			ld (letitbig.num_frame+1),a
			;
			add a,a:add a,a:add a,a:ld l,a ; *8
			ld h,high letitbig.tab_sp:jr nc,2+$+1:inc h
			ld a,(hl):inc hl ; +0 = bank src
			ld (letitbig.eat1stlines_bank+1),a
			ld a,(hl):inc hl ; +1 = bank dest
			ld (letitbig.loop_bank+2),a
			ld e,(hl):inc hl ; +2 = low adr
			ld d,(hl):inc hl ; +3 = hi adr src
			ld (letitbig.eat1stlines_sp+1),de
			ld d,(hl) ; +4 = hi adr dest
			ld (letitbig.loop_sp+1),de
letitbig.next_frame.fix_no_shift
			ld a,(letitbig.next_frame+1):or a:ret z
			;
			inc hl:ld a,(hl) ; +5 = shift x
			ld (letitbig.loop_shift_x+1),a
			; +6 y max jamais utilisé
			
		; shift y
			ld a,(letitbig.shift_y+1)
			dec a;dec a
			ld (letitbig.shift_y+1),a
			
		; optionnel à terme: recopie partielle des lignes du haut	
letitbig.loop_shift_x
			ld a,0
			ld (letitbig.loop_shift_x1+1),a
			ld (letitbig.loop_shift_x2+1),a
			add a,a:add a,#40
			ld (letitbig.loop_shift_x_call1+1),a
			ld (letitbig.loop_shift_x_call2+1),a
			add a,2*44+1:ld l,a
			ld (letitbig.loop_shift_x.call_7FC1+1),a
		ret			
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;				
letitbig.ymod.loop
 			ld (letitbig.mod.tab_sp_adr+1),hl
letitbig.ymod.loop0
			push bc
				call letitbig.mod.update_7FCx_and_HL
				call letitbig.ymod.call_7FC1
			pop bc
 			djnz letitbig.ymod.loop0
		ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.switch_aks_to_top
 			halt ; pour être sûr
			ld a,6*8/2-1+letitbig.constant_r4mod+letitbig.constant_r4aks:ld (letitbig.switch_no_bottom.reg4),a	
			ld a,#21:ld (letitbig.switch_aks_to_top.adr_src),a ; LD HL,xxxx au lieu de CALL xxxx
			halt
			ld a,letitbig.constant_r4aks:ld (letitbig.switch_aks_to_top.adr_rasters+1),a		
			ld a,#CD:ld (letitbig.switch_aks_to_top.adr_dest),a ; réciproque
			ld a,(letitbig.shift_y+1):sub letitbig.constant_r4aks:ld (letitbig.shift_y+1),a
		ret
letitbig.aks_to_top
			call aks_regs
			ld b,1+60/4:djnz$
		ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.script0	; scroll vers le haut jusqu'à avoir l'objet en entier: plus besoin du remplissage dû au shift	
					ld a,(letitbig.shift_y+1):cp 18:ret nz
			 		ld a,#21:ld (letitbig.call_shift_7FC1),a
			 		ld hl,letitbig.script1
letitbig.script_upd	ld (letitbig.script_adr+1),hl:ret;break:ret
letitbig.script1	; jusqu'à dépasser les carrés
					ld a,(letitbig.shift_y+1):cp 8:ret nz
					ld a,6*8/2-1	+letitbig.constant_r4mod	:ld (letitbig.switch_no_bottom.reg4),a	
					ld a,2*8/2		+letitbig.constant_r4mod	:ld (letitbig.switch_no_bottom.reg7),a	
					call letitbig.switch_no_bottom_7FC1
					ld hl,letitbig.script2:jr letitbig.script_upd
letitbig.script2	; jusqu'en haut où on stoppe le scroll et puis active "eat1stlines"
					ld a,(letitbig.shift_y+1):or a:ret nz
					;ld a,(letitbig.next_frame+1):or a:ret nz
					ld a,#C9:ld (letitbig.next_frame.fix_no_shift),a ; plus de shift
					ld hl,letitbig.script3:ld (letitbig.script_adr+1),hl
letitbig.script3
letitbig.eat1stlines
			ld a,(letitbig.next_frame+1):or a
			ld a,(letitbig.eat1stlines_nb+1):jr z,2+$+1:inc a
			ld (letitbig.eat1stlines_nb+1),a
			cp 26:jr nz,2+$+3+3 ; testé: 34
				ld hl,letitbig.script4:ld (letitbig.script_adr+1),hl	
			jp letitbig.eat1stlines_7FC1
letitbig.script4						
			ld a,(letitbig.next_frame+1):or a
			ld a,(letitbig.eat1stlines_nb+1):jr z,2+$+1:dec a
			ld (letitbig.eat1stlines_nb+1),a
			cp 0:jp nz,letitbig.eat1stlines_7FC1
			ld a,1:ld (letitbig.shift_y+1),a
			ld hl,letitbig.script5:jr letitbig.script_upd	
letitbig.script5						
			ld a,(letitbig.next_frame+1):or a:ret z
			;ld a,0:inc a:cp 6:jr nz,2+$+1:xor a:ld ($-7),a:ret nz
			ld a,(letitbig.shift_y+1):inc a:ld (letitbig.shift_y+1),a
			cp 6:ret nz
			ld a,#21:ld (letitbig.script_adr),a
			ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.int
		di
; break
		; synchro
			ld b,2:djnz $:nop
			
			ld bc,#7F8D:out (c),c			; mode 1
		
			push de,hl:exx:ex af,af:push af,bc,de,hl,ix,iy
		
letitbig.switch_aks_to_top.adr_dest
			ld hl,letitbig.aks_to_top  
			call aks_play
			
		; avant le call
			ld de,#100*(high letitbig.adr_vram)+(high (letitbig.adr_vram+#800))						
											; D et E les poids forts de la scanline double R4=0 R9=1
			ld a,high letitbig.code			; poids forts des jumps
			ld ixh,a						; poids forts des jumps
letitbig.shift_y
			ld c,131	; au 1er loop, à augmenter pour décaler l'image vers le bas ; testé: 125
			exx
letitbig.switch_aks_to_top.adr_rasters		
			ld hl,letitbig.rasters 			; HL pour les rasters tous les 2 scanlines
letitbig.loop_bank	
			ld de,#C0C2						; DE #C1C2 utilisé pour la gestion interbank
			ld (letitbig.backup_sp+1),sp
letitbig.loop_sp
			ld sp,0
;			if debug.syncbreak=1
;				break
;			endif										
			ld bc,#BC04:out (c),c:ld bc,#BD00:out (c),c
			ld bc,#7F8E						; B #7F déjà setté sur la couleur
			jp letitbig.scanline
			
		; après le call, retour en 7FC2		
letitbig.post_ret
			ld a,RGB000:out (c),a
 if cond.colorz
 ld hl,#1056:out (c),h:out (c),l ; écran
 else
			ld hl,#0356:out (c),h:out (c),l ; écran
 endif
;			if debug.syncbreak=1
;				break
;			endif		
							
letitbig.switch_no_bottom.reg4 equ $+6	
			ld bc,#BC04:out (c),c:ld bc,#BD00+6*8/2-1:out (c),c
letitbig.switch_no_bottom.reg7 equ $+6	
			ld bc,#BC07:out (c),c:ld bc,#BD00+2*8/2:out (c),c
			
letitbig.backup_sp	
			ld sp,0
	
		; zic, envoi registres au PSG
letitbig.switch_aks_to_top.adr_src
			call aks_regs
			
		; update des données à utiliser	
letitbig.switch_no_next_frame
			call letitbig.next_frame	
			
		; call du script
letitbig.script_adr call letitbig.script0
			
		jp letitbig.int_7FC1_ret
		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	LET IT MOD!   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.mod.update_7FCx_and_HL
letitbig.mod.tab_sp_adr		
			ld hl,letitbig.tab_sp
			ld a,(hl):inc hl ; +0 = bank src
			inc hl ; +1 = bank dest
			ld e,(hl):inc hl ; +2 = lo adr
			ld d,(hl):inc hl ; +3 = lo adr src
			ld (letitbig.mod.set_HL+1),de
			ld (letitbig.mod.set_7FCx+1),a
			inc hl ; +4 = hi adr dest
			inc hl ; +5 = shift x
			inc hl ; +6
			inc hl ; +7 (dummy)
			ld (letitbig.mod.tab_sp_adr+1),hl
		ret		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.mod.tab_l0l1.init
		ld d,high letitbig.mod.tab_l0l1jr
		ld ix,14*5+#500:call letitbig.mod.tab_l0l1.init.subcall
		dec d ; letitbig.mod.tab_l0l1
		ld  ix,1+#FF00:call letitbig.mod.tab_l0l1.init.subcall
			ld h,d
			ld l,low letitbig.scanline1_8fix:ld (hl),8+1:inc h:ld (hl),5*(14-8)
			ld l,low letitbig.scanline1_6fix:ld (hl),5*(14-6):dec h:ld (hl),6+1
			ld l,low letitbig.scanline1_4fix:ld (hl),4+1:inc h:ld (hl),5*(14-4)
		ret
letitbig.mod.tab_l0l1.init.subcall
		xor a:ld e,a:ld (de),a:inc e:jr nz,$-2
		ld hl,letitbig.precalc.tab_l0
		ld b,1+#0C:ld a,ixl:ld e,(hl):ld (de),a:sub ixh:inc l:djnz $-5
		ld b,1+#0C:ld a,ixl:ld e,(hl):ld (de),a:sub ixh:inc l:djnz $-5
		ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.ymod.init
		ld hl,letitbig.ymod.init.data_unroll+5+3-1
		ld de,letitbig.mod.unroll+5*14+3-1
		ld bc,5+3
		lddr
		ld hl,letitbig.mod.unroll+5*14-1
		ld c,5*13
		lddr
		;
		ld hl,letitbig.mod.unroll_decrunch
		ld de,letitbig.precalc.mask+16
		call letitbig.ymod.init_decrunch
		ld hl,letitbig.mod.unroll_decrunch+#100
		ld de,letitbig.precalc.mask+16+#100
		call letitbig.ymod.init_decrunch
		;
		ld hl,letitbig.mod.tab_conv
		ld de,letitbig.ymod.init.data
		ld a,(de):jr letitbig.ymod.init.1st_loop
letitbig.ymod.init.loop0
		ld a,(de):or a:jr nz,letitbig.ymod.init.same_tab
		inc de:ld a,(de):or a:ret z
		inc h:ld l,0 ; next tab
letitbig.ymod.init.1st_loop
		ld (hl),l:inc l:jr nz,$-2
letitbig.ymod.init.same_tab
		ld c,a
		inc de:ld a,(de):ld b,a:inc de
		ld a,c:or #80
letitbig.ymod.init.loop1
		ld l,c:ld (hl),a
		ld l,a:ld (hl),c
		inc c:inc a
		djnz letitbig.ymod.init.loop1
		jr letitbig.ymod.init.loop0
		
letitbig.ymod.init.data
		db 				48-7,13,					0
		db 48-7-22,13,	48-7,13,	48-7+22,13,		0
		db 				       		48-7+22,13,		0
		db 48-7-22,13,								0
	db 0
			
letitbig.ymod.init.data_unroll
					ld e,(hl) ; index x sur la scanline
					ld a,(de) ; index x converti 
					ld (hl),a
					inc l:inc hl 
					exx:ex de,hl:jp (hl)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.ymod.init_decrunch
		ld b,64
letitbig.ymod.init.loop_decrunch
			ld (hl),#36:inc l ; LD (HL),xx
			ld a,(de):ld (hl),a:inc l:inc e
			ld (hl),#2C:inc l ; INC L
			djnz letitbig.ymod.init.loop_decrunch
			dec l:ld (hl),#C9
		; puis la table qui enlève le 0 et mets des 1 à la place
			ld hl,letitbig.mod.conv_nomask
			ld c,-1
letitbig.mod.conv_nomask.loop
			ld a,c:xor l
			ld e,a:add a,a:add a,a:add a,a:add a,a:and e
			or l
			ld (hl),a
			inc l:jr nz,letitbig.mod.conv_nomask.loop	
		ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.decrunch
			call letitbig.decrunch.copybuffer_7FC1
			;
letitbig.decrunch.loop0
			call letitbig.decrunch.double_scanline
			call letitbig.decrunch.adr_sprite
			ld a,128:dec a:ld ($-2),a:jr nz,letitbig.decrunch.loop0
		ret
		;
letitbig.decrunch.adr_sprite					
			ld hl,letitbig.mod.sprite
			call letitbig.mod.unroll_decrunch
			inc hl
			call letitbig.mod.unroll_decrunch+#100
			inc hl
letitbig.decrunch.cpt_nomask
			ld a,12+1:dec a:jr nz,2+$+2:ld a,44:ld (letitbig.decrunch.cpt_nomask+1),a
			sub 23:jr nc,letitbig.decrunch.adr_sprite.ends
			; enlève le mask de 22 à 44
			ld hl,(letitbig.decrunch.adr_sprite+1)
			ld d,high letitbig.mod.conv_nomask
			ld b,64*2
letitbig.decrunch.cpt_nomask.loop
			ld e,(hl):ld a,(de):ld (hl),a
			inc l:djnz letitbig.decrunch.cpt_nomask.loop
			dec l:inc hl
letitbig.decrunch.adr_sprite.ends
			ld (letitbig.decrunch.adr_sprite+1),hl
			ret
letitbig.decrunch.double_scanline
			ld a,7:or a:jr z,letitbig.decrunch.double_scanline.sp_adr
			dec a:ld (letitbig.decrunch.double_scanline+1),a:ret
letitbig.decrunch.double_scanline.sp_adr
			ld hl,letitbig.mod.buffer_sp
			ld d,high letitbig.mod.tab_l0l1
			ld e,(hl):inc l
			ld a,(hl):inc hl
			cp low letitbig.scanline0_blk:jr nz,letitbig.decrunch.not_blank_lines
					ld a,#C9:ld (letitbig.decrunch.double_scanline),a
					ret
letitbig.decrunch.not_blank_lines
				ld b,a
				ld a,(de):ld c,a
				ld e,b
				ld a,(de):ld b,a
				ld d,high letitbig.mod.unroll_decrunch
				call letitbig.decrunch.call_7FC1.subcall
				ld b,c:inc d
				call letitbig.decrunch.call_7FC1.subcall
				ld (letitbig.decrunch.double_scanline.sp_adr+1),hl
				ret
letitbig.decrunch.l0_loop
					ld e,(hl) ; index x sur la scanline
					ld a,e:add a,a:add a,e ; *3
					add a,1-16*3:ld e,a ; adr dans LD (HL),xx:INC L *64
					inc l:ld a,(hl):ld (de),a:inc hl ; octet poké
letitbig.decrunch.call_7FC1.subcall
					djnz letitbig.decrunch.l0_loop
				ret			
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	INIT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.src_code
	phase letitbig.code
letitbig.scanline		out (c),d:exx
						jr letitbig.scanline_1st
letitbig.scanline0_blk	; B pour ce jump, C le nb de double-scanline à sauter
						; 55 µs jusqu'au out
						ld b,(hl):ld b,1+12:djnz $		; 5+12*4+2µs
letitbig.scanline0_bcl equ $-2
						exx:inc b:outi:exx				; 8µs
letitbig.scanline_outi1	equ $-1
						; 3+54 jusqu'au pop des jp
						ld b,1+12:djnz $				; 5+12*4
letitbig.scanline_1st	dec c:jp z,letitbig.scanline1_9_0;4µs si jp
						; 1+7+1 en incluant le jp
						add hl,hl:ld b,1+12+1
						jr letitbig.scanline0_bcl		
letitbig.scanline1_0	ld b,12:djnz $:ld b,(hl)					
						jr letitbig.scanline1_9_0
letitbig.scanline1_1	ld b,11:djnz $
						jr letitbig.scanline1_9_1
letitbig.scanline1_2	ld b,9:djnz $:ld b,(hl)					
						jr letitbig.scanline1_9_2
letitbig.scanline1_3	ld b,8:djnz $
						jr letitbig.scanline1_9_3
letitbig.scanline1_4	ld b,6:djnz $:ld b,(hl)					
						jr letitbig.scanline1_9_4
letitbig.scanline1_4fix	ld b,5:djnz $
						jr letitbig.scanline1_9_4
letitbig.scanline1_5	ld b,5:djnz $
						jr letitbig.scanline1_9_5
letitbig.scanline1_6	ld b,3:djnz $:ld b,(hl)					
						jr letitbig.scanline1_9_6
letitbig.scanline1_6fix	ld b,2:djnz $					; 3+1*6=9µs
						jr letitbig.scanline1_9_6		; 3µs
letitbig.scanline1_7	ld b,2:djnz $					; 3+1*6=9µs
						jr letitbig.scanline1_9_7		; 3µs
letitbig.scanline1_8	jr 2+$							; 3+0*6=3µs
						jr letitbig.scanline1_9_8		; 3µs
letitbig.scanline1_C	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_B	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_A	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_9	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_8fix
letitbig.scanline1_9_8	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_9_7	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_9_6	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_9_5	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_9_4	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_9_3	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_9_2	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_9_1	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline1_9_0	pop bc:ld ixl,c:ld l,b:ld h,a	; 7µs 
						jp (hl)							; 1µs ;;; 62µs 
letitbig.scanline0_0	ld b,12:djnz $:ld b,(hl)					
						ld h,d:jr letitbig.scanline0_9_0
letitbig.scanline0_1	ld b,11:djnz $
						ld h,d:jr letitbig.scanline0_9_1
letitbig.scanline0_2	ld b,9:djnz $:ld b,(hl)					
						ld h,d:jr letitbig.scanline0_9_2
letitbig.scanline0_3	ld b,8:djnz $
						ld h,d:jr letitbig.scanline0_9_3
letitbig.scanline0_4	ld b,6:djnz $:ld b,(hl)					
						ld h,d:jr letitbig.scanline0_9_4
letitbig.scanline0_5	ld b,5:djnz $
						ld h,d:jr letitbig.scanline0_9_5
letitbig.scanline0_6	ld b,3:djnz $:ld b,(hl)					
						ld h,d:jr letitbig.scanline0_9_6
letitbig.scanline0_7	ld b,2:djnz $					; 3+1*6=9µs
						ld h,d:jr letitbig.scanline0_9_7; 4µs
letitbig.scanline0_8	add hl,hl						; 3+0*6=3µs
						ld h,d:jr letitbig.scanline0_9_8; 4µs
letitbig.scanline0_C	ld h,d:pop bc:ld l,c:ld (hl),b	; 7µs /+\ +1µs
letitbig.scanline0_B	ld h,d:pop bc:ld l,c:ld (hl),b	; 7µs /+\ +1µs
letitbig.scanline0_A	ld h,d:pop bc:ld l,c:ld (hl),b	; 7µs /+\ +1µs
letitbig.scanline0_9	ld h,d							; 7µs
						pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline0_9_8	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline0_9_7	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline0_9_6	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline0_9_5	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline0_9_4	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline0_9_3	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline0_9_2	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline0_9_1	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.scanline0_9_0	exx:inc b:outi:exx				; 8µs
letitbig.scanline_outi0 equ $-1
						ld h,e:jp (ix)					; 3µs ;;; 66µs
letitbig.scanline_sp_end
	dephase
letitbig.src_code_end
letitbig.src_code_fix	
						out (c),c ; #7F8E
						out (c),e ; #7FC2
						jp letitbig.post_ret
letitbig.src_code_fix_end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.eat1stlines.src_code
	phase letitbig.eat1stlines.code
letitbig.eat1stlines.scanline		out (c),d:exx
						jr letitbig.eat1stlines.scanline_1st
letitbig.eat1stlines.scanline0_blk	
						defs 5,0;;;ld b,(hl):ld b,1+12:djnz $		; 5+12*4+2µs
letitbig.eat1stlines.scanline0_bcl equ $-2
						defs 5,0;;;exx:inc b:outi:exx				; 8µs
letitbig.eat1stlines.scanline_outi1	equ $-1
						defs 4,0;;;ld b,1+12:djnz $				; 5+12*4
letitbig.eat1stlines.scanline_1st	;;;dec c:jp z,letitbig.eat1stlines.scanline1_9_0;4µs si jp
						jp letitbig.eat1stlines.scanline1_9_0_suite+1
						defs 1,0
						; 1+7+1 en incluant le jp
						defs 3,0;;;add hl,hl:ld b,1+12+1
						defs 2,0;;;jr letitbig.eat1stlines.scanline0_bcl		
letitbig.eat1stlines.scanline1_0	;;;ld b,12:djnz $:ld b,(hl)					
						jr letitbig.eat1stlines.scanline1_9_0
									defs 5,0
letitbig.eat1stlines.scanline1_1	;;;ld b,11:djnz $
						jr letitbig.eat1stlines.scanline1_9_1
									defs 4,0
letitbig.eat1stlines.scanline1_2	;;;ld b,9:djnz $:ld b,(hl)					
						jr letitbig.eat1stlines.scanline1_9_2
									defs 5,0
letitbig.eat1stlines.scanline1_3	;;;ld b,8:djnz $
						jr letitbig.eat1stlines.scanline1_9_3
									defs 4,0
letitbig.eat1stlines.scanline1_4	;;;ld b,6:djnz $:ld b,(hl)					
						jr letitbig.eat1stlines.scanline1_9_4
									defs 5,0
letitbig.eat1stlines.scanline1_4fix	;;;ld b,5:djnz $
						jr letitbig.eat1stlines.scanline1_9_4
									defs 4,0
letitbig.eat1stlines.scanline1_5	;;;ld b,5:djnz $
						jr letitbig.eat1stlines.scanline1_9_5
									defs 4,0
letitbig.eat1stlines.scanline1_6	;;;ld b,3:djnz $:ld b,(hl)					
						jr letitbig.eat1stlines.scanline1_9_6
									defs 5,0
letitbig.eat1stlines.scanline1_6fix	;;;ld b,2:djnz $					; 3+1*6=9µs
						jr letitbig.eat1stlines.scanline1_9_6		; 3µs
									defs 4,0
letitbig.eat1stlines.scanline1_7	;;;ld b,2:djnz $					; 3+1*6=9µs
						jr letitbig.eat1stlines.scanline1_9_7		; 3µs
									defs 4,0
letitbig.eat1stlines.scanline1_8	;;;jr 2+$							; 3+0*6=3µs
						jr letitbig.eat1stlines.scanline1_9_8		; 3µs
									defs 2,0
letitbig.eat1stlines.scanline1_C	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_B	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_A	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_9	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_8fix
letitbig.eat1stlines.scanline1_9_8	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_9_7	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_9_6	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_9_5	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_9_4	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_9_3	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_9_2	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_9_1	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline1_9_0	;;;pop bc:ld ixl,c:ld l,b:ld h,a	; 7µs 
									;;;jp (hl)							; 1µs ;;; 62µs 
									exx:inc b:outi:jr letitbig.eat1stlines.scanline1_9_0_suite
letitbig.eat1stlines.scanline_outi0 equ $-2
letitbig.eat1stlines.scanline0_0	;;;ld b,12:djnz $:ld b,(hl)					
						ld h,d:jr letitbig.eat1stlines.scanline0_9_0
									defs 5,0
letitbig.eat1stlines.scanline0_1	;;;ld b,11:djnz $
						ld h,d:jr letitbig.eat1stlines.scanline0_9_1
									defs 4,0
letitbig.eat1stlines.scanline0_2	;;;ld b,9:djnz $:ld b,(hl)					
						ld h,d:jr letitbig.eat1stlines.scanline0_9_2
									defs 5,0
letitbig.eat1stlines.scanline0_3	;;;ld b,8:djnz $
						ld h,d:jr letitbig.eat1stlines.scanline0_9_3
									defs 4,0
letitbig.eat1stlines.scanline0_4	;;;ld b,6:djnz $:ld b,(hl)					
						ld h,d:jr letitbig.eat1stlines.scanline0_9_4
									defs 5,0
letitbig.eat1stlines.scanline0_5	;;;ld b,5:djnz $
						ld h,d:jr letitbig.eat1stlines.scanline0_9_5
									defs 4,0
letitbig.eat1stlines.scanline0_6	;;;ld b,3:djnz $:ld b,(hl)					
						ld h,d:jr letitbig.eat1stlines.scanline0_9_6
									defs 5,0
letitbig.eat1stlines.scanline0_7	;;;ld b,2:djnz $					; 3+1*6=9µs
						ld h,d:jr letitbig.eat1stlines.scanline0_9_7; 4µs
									defs 4,0
letitbig.eat1stlines.scanline0_8	;;;add hl,hl						; 3+0*6=3µs
						ld h,d:jr letitbig.eat1stlines.scanline0_9_8; 4µs
									defs 1,0
letitbig.eat1stlines.scanline0_C	ld h,d:pop bc:ld l,c:ld (hl),b	; 7µs /+\ +1µs
letitbig.eat1stlines.scanline0_B	ld h,d:pop bc:ld l,c:ld (hl),b	; 7µs /+\ +1µs
letitbig.eat1stlines.scanline0_A	ld h,d:pop bc:ld l,c:ld (hl),b	; 7µs /+\ +1µs
letitbig.eat1stlines.scanline0_9	ld h,d							; 7µs
						pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline0_9_8	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline0_9_7	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline0_9_6	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline0_9_5	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline0_9_4	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline0_9_3	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline0_9_2	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline0_9_1	pop bc:ld l,c:ld (hl),b			; 6µs
letitbig.eat1stlines.scanline0_9_0	
									;;;exx:inc b:outi:exx				; 8µs
;;;letitbig.eat1stlines.scanline_outi0 equ $-1
						ld h,e:jp (ix)					; 3µs ;;; 66µs
letitbig.eat1stlines.scanline1_9_0_suite
									exx
									pop bc:ld ixl,c:ld l,b:ld h,a	; 7µs 
									jp (hl)							; 1µs ;;; 62µs 
letitbig.eat1stlines.scanline_sp_end
	dephase
letitbig.eat1stlines.src_code_end
letitbig.eat1stlines.src_code_fix	
						jp letitbig.eat1stlines.post_ret
letitbig.eat1stlines.src_code_fix_end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; STORE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.store_sp.next_bank.and_re_check call letitbig.store_sp.next_bank
letitbig.store_sp_for_1_frame

						; vérifier qu'il reste de la place où stocker
letitbig.store_sp.adr			ld hl,0
letitbig.store_sp.length		ld bc,0
								add hl,bc
								ex de,hl
letitbig.store_sp.adr_max		ld hl,0 ; max
;								if debug.syncbreak=1
;									break
;									; HL le max
;									; DE où ça va
;									; BC la taille
;								endif
								or a:sbc hl,de
						; si non: prochaine bank
								jr c,letitbig.store_sp.next_bank.and_re_check
						; préciser dans la table la bank (adress et bank différente de lors de la copie)
letitbig.store_sp.tab_sp_adr	ld hl,letitbig.tab_sp
								ld a,(letitbig.store_sp.bank_src+1):ld (hl),a:inc hl	; +0 = bank src
letitbig.store_sp.bank_dest		ld (hl),#C0:inc hl										; +1 = bank dest
								ld de,(letitbig.store_sp.adr+1):ld (hl),e:inc hl		; +2 = low adr
								                                ld (hl),d:inc hl		; +3 = hi adr src
letitbig.store_sp.add_bank		ld a,0:add a,d:ld (hl),a:inc hl							; +4 = hi adr dest
								ld a,(letitbig.precalc.dx_bytescr)
								add a,9 ; testé: 7
								bit 7,a:jr z,2+$+1:xor a ; cas du négatif!
								sub 96-45:add a,96-45:jr c,2+$+2:ld a,96-45
																	ld (hl),a:inc hl 	; +5 = shift x
letitbig.precalc.last_y			ld a,34*4-1:sub 0:ld (hl),a:inc hl						; +6 = last y or so
								inc hl 													; +7 = dummy
								ld (letitbig.store_sp.tab_sp_adr+1),hl
						; stocker
letitbig.store_sp.bank_src		ld a,#C3
								ld hl,letitbig.precalc.buffer
								; de not modified
								; bc not modified = length
								call sys.copy_7FCx
						; prochaine fois...
								ld (letitbig.store_sp.adr+1),de
						; efface . TEMP
								ld hl,letitbig.precalc.buffer
								ld de,letitbig.precalc.buffer+1
								ld bc,letitbig.precalc.buffer_max-letitbig.precalc.buffer-1
								ld (hl),0
								ldir
							ret

letitbig.store_sp.next_bank ; bc is not modified
								ld hl,letitbig.store_sp.tab_bank
								ld e,0
								ld d,(hl):inc hl:ld (letitbig.store_sp.adr+1),de
								ld a,(hl):inc hl:ld (letitbig.store_sp.adr_max+2),a
								ld a,(hl):inc hl:ld (letitbig.store_sp.bank_src+1),a
								ld a,(hl):inc hl:ld (letitbig.store_sp.add_bank+1),a
								ld a,(hl):inc hl:ld (letitbig.store_sp.bank_dest+1),a
								ld (letitbig.store_sp.next_bank+1),hl
							ret

letitbig.store_sp.tab_bank
	;  adr		adr max		bank src	add hi bank		bank dest
														;C4 				code+sfx
														;C5		    <#4900: code again
	db #49,		#80,		#C2,		#00,			#C5 ; #4000
	db #80,		#94,		#C2,		#C0,			#C6 ; #F000
														;C7 				buffer<#E000,code etc
														;					écran en 0000-4000
	db #49,		#80,		#C3,		#80,			#C0	; #C000
	db #40,		#C0,		#C1,		#00,			#C0	; #8000
														
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GEN_SP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.gen_mask				ld hl,letitbig.precalc.ldhl-1
								ld de,letitbig.gen_mask.data
								ld c,#2C:ld a,(de)
letitbig.gen_mask.subcall.lo		ld b,a:inc de
									ld a,(de):inc de
									inc l:ld (hl),a:inc l:ld (hl),c:djnz $-4
								ld a,(de):or a:jr nz,letitbig.gen_mask.subcall.lo
								ld (hl),#C9
								ret
letitbig.gen_mask.data	
						db 16+4,#72,11,#71,11,#72,11,#73,11,#72,11,#71,5+16,#72,0
						; ld (hl),c:ld (hl),d:ld (hl),e:inc l === #71 #72 #73 #2C
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.precalc.tab_l0	db l00,l01,l02,l03,l04,l05,l06,l07,l08,l09,l0A,l0B,l0C
letitbig.precalc.tab_l1	db l10,l11,l12,l13,l14,l15,l16,l17,l18,l19,l1A,l1B,l1C	
	assert (high ($+1)) = (high letitbig.precalc.tab_l0)	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
l00 	equ (low letitbig.scanline0_0)
l01 	equ (low letitbig.scanline0_1)
l02 	equ (low letitbig.scanline0_2)
l03	 	equ (low letitbig.scanline0_3)
l04 	equ (low letitbig.scanline0_4)
l05 	equ (low letitbig.scanline0_5)
l06 	equ (low letitbig.scanline0_6)
l07 	equ (low letitbig.scanline0_7)
l08 	equ (low letitbig.scanline0_8)
l09 	equ (low letitbig.scanline0_9)
l0A 	equ (low letitbig.scanline0_A)
l0B 	equ (low letitbig.scanline0_B)
l0C 	equ (low letitbig.scanline0_C)
l10 	equ (low letitbig.scanline1_0)
l11 	equ (low letitbig.scanline1_1)
l12 	equ (low letitbig.scanline1_2)
l13 	equ (low letitbig.scanline1_3)
l14	 	equ (low letitbig.scanline1_4)
l15 	equ (low letitbig.scanline1_5)
l16 	equ (low letitbig.scanline1_6)
l17 	equ (low letitbig.scanline1_7)
l18 	equ (low letitbig.scanline1_8)
l19 	equ (low letitbig.scanline1_9)	
l1A 	equ (low letitbig.scanline1_A)	
l1B 	equ (low letitbig.scanline1_B)	
l1C 	equ (low letitbig.scanline1_C)	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.precalc_1_frame_wo_store

	; vide le buffer des ligne: 1 seule fois suffit; mais quelle largeur?
			ld hl,letitbig.precalc.buff_l0+64:xor a:dec l:ld (hl),a:jr nz,$-2
			ld hl,letitbig.precalc.buff_l1+64:xor a:dec l:ld (hl),a:jr nz,$-2

			; init minmax en x
				ld a,(@rot.scr.xminmax+2) 				; min
				srl a:srl a:ld c,a
				ld (letitbig.precalc.spr_adr_x+1),a
				ld (letitbig.precalc.buf_add0+1),a
				ld (letitbig.precalc.buf_add1+1),a
				ld a,(@rot.scr.xminmax+1) 				; max
				srl a:srl a:inc a
				sub c									; width
				ld (letitbig.precalc.width0+2),a
				ld (letitbig.precalc.width1+2),a
				neg:add a,#40+1							; then add
				ld (letitbig.precalc.spr_add0+1),a
				ld (letitbig.precalc.spr_add1+1),a
				
			; init minmax en y
				ld a,(@rot.scr.yminmax+1):neg			 	; min
				srl a:ld c,a
				ld (letitbig.precalc.y_add_first+1),a
				ld d,c:ld e,0:srl d:rr e
letitbig.precalc.spr_adr_x
				ld hl,letitbig.precalc.sprite.gameboy
				add hl,de:ld (letitbig.precalc.spr_adr+1),hl
				ld a,(@rot.scr.yminmax+2):neg 				; max
				inc a ; faut effacer, revenir au zéro
				srl a;ld b,a
				ld (letitbig.precalc.last_y+3),a
				sub c
				inc a
				ld (letitbig.precalc.y_length+2),a		; length
				;ld a,33*4-1:sub b 						; <--- 
				;ld (letitbig.precalc.y_add_last+1),a		; last

			; init avant loop
				xor a:ld (letitbig.precalc.delay+1),a
letitbig.precalc.spr_adr
				ld hl,letitbig.precalc.sprite
				ld ixh,high letitbig.precalc.tab_l0
letitbig.precalc.y_length
				ld iyh,128
				exx:ld de,letitbig.precalc.buffer
				ld h,high @rot.tab.mask
				ld b,high letitbig.precalc.mask
				
			; début du store
letitbig.precalc.y_add_first
				ld a,2:sub letitbig.constant_ymin
				;jr nc,2+$+2:break:jr nz,2+$+2:break
				or a:jr z,letitbig.precalc.y_add_first.zero
				ld (de),a:inc e:ld a,low letitbig.scanline0_blk:ld (de),a:inc de
letitbig.precalc.y_add_first.zero
			
letitbig.precalc.loop_2lines
					push de:inc e
					push de:inc de
						ld ixl,low letitbig.precalc.tab_l0
						exx
letitbig.precalc.width0
							ld bc,#4000
letitbig.precalc.buf_add0
							ld de,letitbig.precalc.buff_l0
							call letitbig.precalc.do_1_line
							ld a,ixl:sub low letitbig.precalc.tab_l0+10:jr c,letitbig.precalc.lin0_ok
								inc a
								if obsolete.letitbig=1
									sub 3:add a,3:jr c,2+$+2:break ; dans A le nb en trop sur la ligne
								endif							
								ld c,a:add a,a:ld b,a:add a,a:add a,b:add a,c:ld c,a ;*7
								ld a,(letitbig.precalc.delay+1):add a,c:ld (letitbig.precalc.delay+1),a
letitbig.precalc.lin0_ok	ld a,(ix+0)
						ld ixl,low letitbig.precalc.tab_l1
 						pop bc:ld (bc),a
letitbig.precalc.spr_add0
 						ld bc,0:add hl,bc
 						exx:inc b:exx
letitbig.precalc.width1
							ld bc,#4000
letitbig.precalc.buf_add1
							ld de,letitbig.precalc.buff_l1
							call letitbig.precalc.do_1_line						
							ld a,ixl:sub low letitbig.precalc.tab_l1+10:jr c,letitbig.precalc.lin1_ok
								inc a
								if obsolete.letitbig=1
									sub 3:add a,3:jr c,2+$+2:break ; dans A le nb en trop sur la ligne
								endif							
								add a,a:ld b,a:add a,a:add a,b:ld c,a ;*6
								ld a,(letitbig.precalc.delay+1):add a,c:ld (letitbig.precalc.delay+1),a
letitbig.precalc.lin1_ok		
letitbig.precalc.delay		ld a,0:sub 6
							ld a,(ix+0)
							jr c,letitbig.precalc.no_delay	
							; delay to recover
								ld a,(letitbig.precalc.delay+1)
								if obsolete.letitbig=1
									break ; dans A le nb de NOP-cyle à rattraper
								endif
								ld b,a:sub 6:ld c,a
								ld a,(ix+0)
 								cp l18:jr nz,2+$+3:ld a,low letitbig.scanline1_8fix:ld b,c	
 								cp l16:jr nz,2+$+3:ld a,low letitbig.scanline1_6fix:ld b,c	
 								cp l14:jr nz,2+$+3:ld a,low letitbig.scanline1_4fix:ld b,c	
								;cp l12:jr nz,2+$+3:ld a,low letitbig.scanline1_2fix:ld b,c	
								ld c,a:ld a,b:ld (letitbig.precalc.delay+1),a:ld a,c
letitbig.precalc.no_delay
						pop bc:ld (bc),a
letitbig.precalc.spr_add1
 						ld bc,0:add hl,bc
						exx:dec b
					dec iyh
					jp nz,letitbig.precalc.loop_2lines
					
	; archi temporaire, pour voir la taille et max d'octets par ligne
		if obsolete.letitbig
			ld hl,letitbig.precalc.buffer_max:or a:sbc hl,de
			jr nc,2+$+2:break
		endif

	
;letitbig.precalc.y_add_last
			ld a,-1:ld (de),a:inc e:ld a,low letitbig.scanline0_blk:ld (de),a:inc de
	 
		; de = l'adresse dans letitbig.precalc.buffer 			
			ex de,hl
			ld de,letitbig.precalc.buffer:or a:sbc hl,de
			ld (letitbig.store_sp.length+1),hl
		; taille stockée	
			
		ret
				
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; hl  = sprite buffer
	; de  = line(0/1)buffer
	; b = #40 == width
	; c = 00
	; de' = sp buffer
	; b' = letitbig.precalc.mask	
	; h' = @rot.tab.mask
	; ixl = ...+nb bytes in line
letitbig.precalc.loop_in_line	ld (hl),c
								dec b:ret z
								inc e:inc l
letitbig.precalc.do_1_line			ld a,(de):cp (hl)
 									jr z,letitbig.precalc.loop_in_line
									; byte has changed
										ld a,e:exx					; où dans la ligne
letitbig.precalc.dx_bytescr equ $+1
										add a,0
										ld (de),a:inc e				; 1) stock index
											ld c,a					; mask: quelle trame/colonne? dans (bc)
										exx:ld a,(hl):ld (de),a:exx	; nouvel octet
											ld l,a					; mask: octet maské hl=@rot.tab.mask
											ld a,(bc):and (hl):or l	; mask: quelle trame/colonne avec quel mask?
										ld (de),a:inc de			; 2) stock byte
										inc ixl:exx					; next! ...		 
										jr letitbig.precalc.loop_in_line
		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	GAMEBOY ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
letitbig.gameboy.precalc
		
		; init objet
 			ld hl,tab.pts.gameboy:call @rot.reset_all
			ld b,%00001111:ld c,%10100101:ld d,%11111111:call @rot.gen.trans_ink ; 2 / 1&2 / 3
 	 		ld hl,#C000:ld (rot.ax_16bits),hl
 	 		ld hl,#0CF2+#18-9:ld (rot.az_16bits),hl
 	 		ld hl,#0000:ld (rot.ay_16bits),hl
 	 		
 	 	; init avant le loop qui store
			call letitbig.store_sp.next_bank
			call letitbig.gen_mask
			ld hl,letitbig.precalc.mask
			ld de,#F000
			ld c,#A0
			call letitbig.precalc.ldhl
			ld hl,letitbig.precalc.mask+#100
			ld c,#50
			call letitbig.precalc.ldhl
			
			
letitbig.gameboy.precalc.loop

 	 	; fix en loose pour enlever toute la face avant
 	 		ld a,(rot.ay_16bits+1):sub #3E:sub #84:ld hl,#0001:jr nc,2+$+3:ld hl,#FFFF:ld (@rot.tab.sides_full+#37),hl 
 	 	; fix en loose pour enlever la face arrière juste au bon moment 	 		
 	 		ld a,(rot.ay_16bits+1):sub #3E:sub #4:ld hl,#0901:jr nc,2+$+3:ld hl,#FFFF:ld (@rot.tab.sides_full+#2D),hl 
	
		; zoom
 			ld a,(rot.ay_16bits+1) ; poids fort
 			add a,#40
 			call @sys.sinus_16384 ;
 			ld a,#40:sub h ; #00..80
 			srl a:ld e,a:ld d,0:xor a
 			ld hl,#200:sbc hl,de
 			ld (rot.mulu),hl
			
 			
	; rotation des points etc, sans tracer
 			call @rot.gen_all
 			
 		
	; dx (une fois les points rotationnés etc)
		; nouveau dx=?
 			ld a,(rot.ay_16bits+1) ; poids fort
 			add a,#80;+12
 			call @sys.sinus_16384 ; de #40 > -#40 > #40
 			ld de,#4000:add hl,de ; de 00 à #80
 			ld b,0:add hl,hl ; de 00 à #100
 			jr nc,2+$+2:ld b,#40 
		; dxraw	== hl
			ld a,h:and 11111100b:ld c,a:xor h:ld h,a
			ld (letitbig.add_dx+1),hl
			ld a,c:rrca:rrca
			add a,b
			sub 16
			ld (letitbig.precalc.dx_bytescr),a
		; dx on each point
letitbig.add_dx
			ld de,0
			ld hl,@rot.tab.pts_proj:ld a,(@rot.nbpts):ld b,a
letitbig.loop_add_dx	ld a,e:add a,(hl):ld (hl),a:inc hl
		 				ld a,d:adc a,(hl):ld (hl),a:inc hl
		 				inc hl:inc hl
					djnz letitbig.loop_add_dx
	  					
		; draw				
			call @rot.draw_all
		; crunch
			call letitbig.precalc_1_frame_wo_store
		; store
			call letitbig.store_sp_for_1_frame
	 		
		; nouvel angle de la rotation = 
	 		ld hl,(rot.ay_16bits):ld bc,#10000-#10000/letitbig.constant.nb_frames:add hl,bc:ld (rot.ay_16bits),hl
	 		
	 	; loop?
			ld a,#38:dec a:ld ($-2),a:jp nz,letitbig.gameboy.precalc.loop
						
			ret					
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
tab.pts.gameboy
d_gboy = -6
p_gboy = 11-1
dyb_gboy = 1
dyc_gboy = 1 ; croix plus haute
dlo_gboy = -0
bez_gboy = 3 ; bezel plus petit
cro_gboy = 1 ; croix plus petite
lrg_gboy = 2 ; largeur de la gboy
xtr_gboy = 0 ; décalage des boutons extra
;pts
	; face avant 0..4
		db -30+lrg_gboy,d_gboy, 47
		db  30-lrg_gboy,d_gboy, 47
		db  30-lrg_gboy,d_gboy,-39-dlo_gboy
		db  22-lrg_gboy,d_gboy,-47-dlo_gboy
		db -30+lrg_gboy,d_gboy,-47-dlo_gboy
	; face arrière 5..9
		db -30+lrg_gboy,d_gboy+p_gboy, 47
		db  30-lrg_gboy,d_gboy+p_gboy, 47
		db  30-lrg_gboy,d_gboy+p_gboy,-39-dlo_gboy
		db  22-lrg_gboy,d_gboy+p_gboy,-47-dlo_gboy
		db -30+lrg_gboy,d_gboy+p_gboy,-47-dlo_gboy
	; bezel 10..14
		db -26+bez_gboy,d_gboy, 42
		db  26-bez_gboy,d_gboy, 42
		db  26-bez_gboy,d_gboy,  5
		db  20-bez_gboy,d_gboy,  0
		db -26+bez_gboy,d_gboy,  0
	; bouton 15..22
		db  13-lrg_gboy-2,d_gboy,-24+dyb_gboy
		db  11-lrg_gboy-2,d_gboy,-22+dyb_gboy
		db  11-lrg_gboy-2,d_gboy,-19+dyb_gboy
		db  13-lrg_gboy-2,d_gboy,-17+dyb_gboy
		db  16-lrg_gboy-2,d_gboy,-17+dyb_gboy
		db  18-lrg_gboy-2,d_gboy,-19+dyb_gboy
		db  18-lrg_gboy-2,d_gboy,-22+dyb_gboy
		db  16-lrg_gboy-2,d_gboy,-24+dyb_gboy
	; bouton 23..30
		db  21-lrg_gboy-1,d_gboy,-20+dyb_gboy
		db  19-lrg_gboy-1,d_gboy,-18+dyb_gboy
		db  19-lrg_gboy-1,d_gboy,-15+dyb_gboy
		db  21-lrg_gboy-1,d_gboy,-13+dyb_gboy
		db  24-lrg_gboy-1,d_gboy,-13+dyb_gboy
		db  26-lrg_gboy-1,d_gboy,-15+dyb_gboy
		db  26-lrg_gboy-1,d_gboy,-18+dyb_gboy
		db  24-lrg_gboy-1,d_gboy,-20+dyb_gboy
 	; écran 31..34
 		db -16,d_gboy, 37
 		db  16,d_gboy, 37
 		db  16,d_gboy,  5
 		db -16,d_gboy,  5
	; croix 35..42
		db -18+1*cro_gboy+0*lrg_gboy,d_gboy,-10+dyc_gboy+0*cro_gboy
		db -18+1*cro_gboy+0*lrg_gboy,d_gboy,-26+dyc_gboy+2*cro_gboy
		db -14+1*cro_gboy+0*lrg_gboy,d_gboy,-26+dyc_gboy+2*cro_gboy
		db -14+1*cro_gboy+0*lrg_gboy,d_gboy,-10+dyc_gboy+0*cro_gboy
		db -24+2*cro_gboy+0*lrg_gboy,d_gboy,-16+dyc_gboy+1*cro_gboy
		db -24+2*cro_gboy+0*lrg_gboy,d_gboy,-20+dyc_gboy+1*cro_gboy
		db  -8+0*cro_gboy+0*lrg_gboy,d_gboy,-20+dyc_gboy+1*cro_gboy
		db  -8+0*cro_gboy+0*lrg_gboy,d_gboy,-16+dyc_gboy+1*cro_gboy
;	; ptites barres
;		db 	-2	+3+1,	d_gboy,-31+3	-xtr_gboy
;		db  -2	-3+1,	d_gboy,-31		-xtr_gboy
;		db 	-2	-3,		d_gboy,-30		-xtr_gboy
;		db  -2	+3,		d_gboy,-30+3	-xtr_gboy
;		db 	-9	+3+1,	d_gboy,-31+3	-xtr_gboy
;		db  -9	-3+1,	d_gboy,-31		-xtr_gboy
;		db 	-9	-3,		d_gboy,-30		-xtr_gboy
;		db  -9	+3,		d_gboy,-30+3	-xtr_gboy
; 	; LED
; 		db -21,d_gboy, 32
; 		db -23,d_gboy, 32
; 		db -23,d_gboy, 34
; 		db -21,d_gboy, 34
	db -1
;sides
	db 0 ; 1er objet
		; les côtés des faces
			db 1,0,5,6,#82 ; db 0,5,6,1,#82
			db 1,6,7,2,#82
			db 2,7,8,3,#82
			db 9,4,3,8,#82 ; db 3,8,9,4,#82
			db 4,9,5,0,#82
		; face arrière
			db 9,8,7,6,5,#81	
		; face avant
			db 0,1,2,3,4,#81	
		; bezel
			db 12,13,14,10,11,#83
		; boutons
			db 19,20,21,22,15,16,17,18,#82
			db 27,28,29,30,23,24,25,26,#82
	 	; écran
	 		db 31,32,33,34,#81
;	 	; ptites barres
;	 		db 43,44,45,46,#82
;	 		db 47,48,49,50,#82
; 	 	; LED
; 	 		db 47,48,49,50,#82
		db -2
 	db 0 ; 
		; croix
			db 35,38,37,36,#81
		db -1 ; en dessin direct sans traduction en trame	
 	db 0 ; 
		; croix
			db 39,42,41,40,#81
		db -1 ; en dessin direct sans traduction en trame	
	db -1 ; end of sides

									